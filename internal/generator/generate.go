//go:generate go-wrap -mode=priv
package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"
	"text/template"

	"github.com/catmorte/go-ioc/internal/declaration"
	. "github.com/catmorte/go-wrap/pkg/wrap"
	"golang.org/x/tools/imports"
)

const fileTemplate = `
// Code generated by "go-ioc"; DO NOT EDIT.
package {{.PackageName}}
import (
{{range .Imports -}}
		{{if .Alias }} {{.Alias }} {{end -}}
		"{{.Path}}"
{{end -}}
)

{{if .PrintRaw}}
{{range .Funcs}}
{{.Code}}
{{end}}
{{ else}}
func init() {
	{{range $structIndex, $struct := .File.Structs -}} 
		{{range $fieldIndex, $field := $struct.Fields -}} 
			{{if $field.Meta.Tag -}}
				{{if eq (DerefString $field.Meta.Tag) "" -}}
				dep{{$structIndex}}_{{ $fieldIndex }} := {{$.IocPackageAlias}}Dep[{{$field.Code}}]()
	  		{{else -}}
				dep{{$structIndex}}_{{ $fieldIndex }} := {{$.IocPackageAlias}}DepScoped[{{$field.Code}}]("{{DerefString $field.Meta.Tag}}")
  			{{end -}}
  		{{end -}}
  	{{end -}}
		{{$.IocPackageAlias}}{{Reg $struct $.File.Imports}}func() {{Ret $struct}} {
			v := {{if isPtr $struct}}&{{end}}{{$struct.Name}}{
				{{range $fieldIndex, $field := $struct.Fields -}} 
					{{if $field.Meta.Tag -}} 
          	{{$field.Meta.Name}}: {{$.IocPackageAlias}}ResolveDep[{{$field.Code}}](dep{{$structIndex}}_{{ $fieldIndex }}),
  				{{end -}} 
  			{{end -}}
			}
			v.Init()
			return v
		}, {{range $fieldIndex, $field := $struct.Fields -}} 
			{{- if $field.Meta.Tag -}} 
				dep{{$structIndex}}_{{ $fieldIndex }},
  		{{- end -}} 
  	{{- end -}}
  )
  {{end }}
}
{{end }}
`

type fileTemplateData struct {
	PackageName     string
	IocPackageAlias string
	PrintRaw        bool
	declaration.File
}

func getIocPrefix(imports []*declaration.Import) string {
	var imp *declaration.Import
	for _, i := range imports {
		if i.Path == declaration.IocPkgContextPath && i.Alias != "_" && i.Alias != "" {
			imp = i
		}
	}
	if imp == nil || imp.Alias == "." {
		return ""
	}
	return fmt.Sprintf("%s.", imp.Alias)
}

func getRegFuncName(imp *declaration.Import, f *declaration.Type[declaration.StructFieldMeta]) string {
	suffix := "("
	if f.Meta.Tag != nil {
		suffix = fmt.Sprintf("Scoped(\"%s\",", (*f.Meta.Tag))
	}
	if imp.Path == declaration.IocPkgSingletonPath {
		return "Reg" + suffix
	}
	return "RegPrototype" + suffix
}

func parseTemplate() (*template.Template, error) {
	return template.New("").Funcs(template.FuncMap{
		"isPtr": func(s *declaration.Struct) bool {
			return strings.HasPrefix(s.Bean.Meta.Index.Index.Code, "*")
		},
		"DerefString": func(i *string) string { return *i },
		"Ret": func(s *declaration.Struct) string {
			return s.Bean.Meta.Index.Index.Code
		},
		"Reg": func(s *declaration.Struct, imports []*declaration.Import) string {
			for _, imp := range imports {
				if imp.Alias == "_" {
					continue
				}
				if imp.Alias == "" &&
					(strings.HasPrefix(s.Bean.Meta.Index.Field.Code, declaration.IocPkgSingletonAlias+".") ||
						strings.HasPrefix(s.Bean.Meta.Index.Field.Code, declaration.IocPkgPrototypeAlias+".")) {
					return getRegFuncName(imp, s.Bean)
				}
				if imp.Alias == "." && strings.HasPrefix(s.Bean.Meta.Index.Field.Code, declaration.IocBeanStructName) {
					return getRegFuncName(imp, s.Bean)
				}
				if strings.HasPrefix(s.Bean.Meta.Index.Field.Code, imp.Alias+".") {
					return getRegFuncName(imp, s.Bean)
				}
			}
			return "RegUnknown"
		},
	}).Parse(fileTemplate)
}

func executeTemplate[T any](t *template.Template, data T) ([]byte, error) {
	buf := new(bytes.Buffer)
	err := t.Execute(buf, data)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func newFileTemplateData(prefix string, packageName string, f declaration.File, printRaw bool) fileTemplateData {
	return fileTemplateData{
		PackageName:     packageName,
		File:            f,
		IocPackageAlias: prefix,
		PrintRaw:        printRaw,
	}
}

func formatSource(b []byte) ([]byte, error) {
	return format.Source(b)
}

func formatImports(b []byte) ([]byte, error) {
	return imports.Process("", b, nil)
}

func Generate(packageName string, f declaration.File, printRaw bool) Out[[]byte] {
	gotIocPreifx := getIocPrefixWrap(f.Imports)
	templateDataCreated := AndX4Async(gotIocPreifx, OK(packageName), OK(f), OK(printRaw), newFileTemplateDataWrap)
	templateParsed := parseTemplateWrap()
	return AndX2Async(templateParsed, templateDataCreated, func(t *template.Template, data fileTemplateData) Out[[]byte] {
		codeGenerated := executeTemplateWrap(t, data)
		codeFormatted := AndAsync(codeGenerated, formatSourceWrap)
		return AndAsync(codeFormatted, formatImportsWrap)
	})
}
